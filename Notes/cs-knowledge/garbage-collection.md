# 가비지 컬렉션

자동 메모리 관리의 형태로, 프로그램이 동적으로 할당했던 메모리 영역 중 더 이상 사용되지 않는 영역(Garbage)을 식별하고,
자동으로 회수하여 재사용 가능한 자원으로 만드는 과정입니다.

메모리 관리를 수동으로 하지 않아도 되도록 돕기 때문에 개발자에게 큰 이점을 제공하지만, 시스템 리소스를 소모하며 불필요한 지연을 발생시킬 수 있는 단점도 있습니다.

<br>

## 작동 원리

가비지 컬렉션은 크게 2가지 방식으로 동작합니다.

1. **식별**
  - 루트로부터 시작하여 참조되고 있는 모든 객체를 추적합니다.
  - 스택, 레지스터, 전역 변수 등은 이러한 추적 작업의 출발점으로, 이 과정에서 도달할 수 없는 객체, 즉 어떠한 루트에서도 참조되지 않는 객체는 `Garbage` 로 간주됩니다.
2. **회수**
  - 추적 과정이 끝나면, 가비지 컬렉터는 가비지로 식별된 메모리 영역을 회수합니다.
  - 회수된 메모리는 다시 사용 가능한 풀에 반환되어, 새로운 객체 할당에 사용될 수 있습니다.

<br>

## 전략

가비지 컬렉션은 다양한 전략을 사용하여 동작할 수 있습니다.

- **참조 카운트 (Reference Counting)**
  - 객체에 연결된 참조 수를 추적합니다.
  - 참조 수가 0이 되면, 그 객체는 즉시 회수됩니다.
  - 순환 참조가 발생하는 경우, 이 방법만으로는 가비지를 정확히 식별할 수 없습니다.

- **트레이싱 (Tracing)**
  - 루트로부터 시작하여 참조되고 있는 모든 객체를 추적합니다.
  - 도달할 수 없는 객체는 가비지로 간주됩니다.
  - 순환 참조가 발생하는 경우에도 가비지를 정확히 식별할 수 있습니다.

- **참조 카운트 + 트레이싱**
  - 참조 카운트 방식으로 가비지를 식별하고, 트레이싱 방식으로 순환 참조를 해결합니다.
  - 대부분의 언어에서 사용되는 방식입니다.

- **Mark-and-Sweep**
  - **"표시하고 청소"** 하는 방식으로, 살아있는 객체를 표시하고, 표시되지 않은 객체(가비지)를 메모리에서 제거합니다.
  - 이 방법은 메모리를 효율적으로 정리하지만, 청소 과정 중에는 프로그램 실행이 일시 중지될 수 있습니다(Stop-The-World).

- **Generational GC**
  - 객체들을 여러 세대로 나눕니다(일반적으로 "새로운 세대" 와 "오래된 세대").
  - 대부분의 객체는 생성 후 짧은 시간 내에 소멸되므로, 가비지 컬렉션은 주로 "새로운 세대" 에 초점을 맞춥니다.
  - 오래된 세대의 컬렉션은 드물게 발생합니다.

<br>

## 장점

1. **메모리 누수 방지**: 자동으로 더 이상 사용되지 않는 객체를 회수함으로써 메모리 누수 가능성을 줄여줍니다.
2. **프로그램 안정성 향상**: 메모리 오류를 줄이고, 프로그램의 안정성과 신뢰성을 향상시킵니다.

<br>

## 단점

1. **오버헤드**: 가비지 컬렉션 작업은 CPU 시간을 소모하며, 때로는 프로그램의 성능을 저하시킬 수 있습니다.
2. **예측 불가능**: 가비지 컬렉션 동작 시기와 지연 시간은 일반적으로 예측하기 어렵습니다.
3. **메모리 사용 증가**: 가비지 컬렉션을 위한 추가 메모리가 필요할 수 있습니다.

<br>

## 정리

가비지 컬렉션은 메모리 관리를 단순화하지만, 모든 환경과 요구 사항에 적합한 것은 아닙니다.

때문에, 성능이 중요한 시스템이나 메모리 사용량이 제한적인 시스템(임베디드 시스템 등)에서는 주의해서 사용해야 합니다.