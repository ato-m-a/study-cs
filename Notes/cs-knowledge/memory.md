# 메모리

컴퓨터의 메모리 계층 구조는 성능, 비용, 용량을 최적화하기 위해 여러 레벨의 스토리지로 구성됩니다.

기본적으로 빠를 수록 용량이 적고 비싸며, 느릴 수록 용량이 많고 저렴합니다.

<br>

## 계층 구조

1. **상위 레벨**
  - 빠르고, 비싸고, 용량이 작습니다.
  - `레지스터 (CPU)` 와 `캐시 (CPU)` 가 있습니다.

2. **중간 레벨**
  - `메인 메모리 (RAM)` 가 있습니다.

3. **하위 레벨**
  - 느리고, 저렴하고, 용량이 큽니다.
  - `보조 기억장치 (HDD, SSD)` 가 있습니다.

<br>

## 가상 메모리

일반적으로 한 시스템의 프로세스들은 CPU, 메인 메모리를 공유합니다. CPU를 공유하는 부분에 대해서는 순서를 기다리느라 단지 느려질 뿐입니다. 

그러나, 프로세스들이 존재하는 메모리가 여유가 없이 지나치게 많은 요구에 의해 오염될 경우 프로그램의 논리와 무관하게 오류가 발생하고, 이를 방지하기 위해 가상 메모리가 사용됩니다.

가상 메모리는 프로세스가 사용하는 메모리 공간을 논리적으로 분리하여, 각 프로세스가 독립적으로 메모리를 사용하는 것처럼 보이게 합니다.

현대의 CPU는 전부 `MMU` 라는 메모리 관리 유닛을 별도로 내장하고 있습니다. `MMU` 는 가상 메모리를 실제 메모리로 변환하는 역할과 함께, 메모리 보호, 캐시 관리,
버스 중재 등의 역할을 수행하며 간단한 8비트 아키텍처에서는 `뱅크 스위칭` 을 담당하기도 합니다.

1. **기능**
  - **메모리 관리의 단순화**: 각 프로세스마다 가상 메모리의 동일한 주소 공간을 배정할 수 있어 메모리 관리가 단순해집니다.
  - **메모리 용량 및 안정성 보장**: 한정된 공간의 `RAM` 이 아닌 거의 무한한 가상 메모리 공간을 배정함으로써 프로세스 간에 메모리 침범이 일어날 여지를 크게 줄입니다.

2. **방식**
  - **디스크 스왑**
    - 가상 메모리 기술로 실제 존재하지 않는 메모리 영역을 할당할 수 있지만, 물리적인 메모리 공간이 부족하다면 `페이지 폴트 (Page Fault)` 가 발생하여 프로세스가 종료될 수 있습니다.
    - 이를 방지하기 위해, 메모리에 적재된 프로세스 중 일부를 `디스크` 로 내보내어 메모리 공간을 확보하는 방식입니다.
    - 메인 메모리(RAM, Cache Memory)의 비용이 비싸고, 보조 기억장치(HDD, SSD)는 상대적으로 비용이 싸기 때문에 등장한 방법입니다.
    - 보조 메모리가 메인 메모리보다 느리기 때문에 병목현상이 발생하여 전체적인 시스템 성능이 다소 저하되는 경향이 있습니다.
  - **메모리 압축**
    - `zRAM`, `zSwap` (Linux) 등의 기술을 사용하여 메모리를 압축하여 메모리를 확보하는 방식입니다.
    - 메모리를 과다하게 사용할 때에는 압축에 따른 오버헤드가 발생하여 CPU 사용률이 증가하고, 스마트폰과 같은 기기에서는 배터리 사용량도 함께 증가한다는 단점이 있습니다.

<br>

## 메모리 최적화 전략

메모리 최적화는 소프트웨어 성능을 향상시키고, 시스템의 안정성을 유지하며, 리소스 사용을 최소화하는 데 중요한 역할을 합니다.

특히 제한된 메모리 리소스가 있는 시스템이나, 대규모 데이터를 처리해야 하는 애플리케이션에서는 더욱 중요합니다.

1. **메모리 누수 방지**
  - 프로그램이 더 이상 필요하지 않은 메모리를 계속 점유하고 있는 상황을 말합니다.
  - 시간이 지남에 따라 사용 가능한 메모리 양을 줄여 시스템 성능을 저하시킬 수 있습니다.
  - 메모리 누수를 방지하기 위해, 프로그램이 더 이상 필요하지 않은 메모리를 추적하고 해제하는 작업이 필요합니다.

2. **객체 폴링**
  - 자주 생성하고 제거되는 객체들은 메모리 할당과 해제로 인한 오버헤드가 발생할 수 있습니다.
  - 이를 방지하기 위해, 객체를 재사용함으로써 메모리 할당의 횟수를 줄이고 성능을 향상시키는 전략입니다.

3. **데이터 구조 최적화**
  - 데이터 구조는 메모리를 효율적으로 사용하기 위해 최적화되어야 합니다.
  - 예를 들어, 필요 이상으로 큰 자료형을 사용하지 않거나 비효율적인 데이터 구조를 피하고, 필요한 만큼의 메모리만 사용하도록 구조를 설계합니다.

4. **메모리 할당 전략 개선**
  - 가능한 한 덜 복잡한 메모리 할당 전략을 사용하는 것이 좋습니다.
  - 큰 블록의 메모리를 한 번에 할당하고 내부적으로 분배하는 전략 등을 고려할 수 있습니다.

5. **캐싱 전략 사용**
  - 자주 접근하는 객체나 데이터는 메모리에 캐시하여 재사용합니다.
  - 단, 캐시의 크기나 생명주기를 관리하는 것이 중요합니다.

6. **지연 로딩 (Lazy Loading) 기법**
  - 필요한 시점까지 객체의 로딩이나 초기화를 미룹니다.
  - 이를 통해 초기 애플리케이션 시작 시의 메모리 사용량을 줄일 수 있습니다.

7. **메모리 프로파일링**
  - 메모리 프로파일러를 사용하여 애플리케이션의 메모리 사용 패턴을 분석합니다.
  - 이를 통해 메모리 누수를 찾고, 분석을 바탕으로 최적화를 진행합니다.

8. **가비지 컬렉션 최적화**
  - 가비지 컬렉션 동작 방식을 이해하고, 필요에 따라 설정을 조정하여 메모리 성능을 최적화합니다.
  - 불필요한 가비지 컬렉션 동작을 최소화하도록 코드를 구성합니다.

<br>

## 멀티스레딩과 동시성

1. **멀티스레딩과 동시성**
  - 멀티스레딩은 하나의 프로세스 내에서 여러 개의 스레드가 동시에 작업을 수행하는 것을 말합니다.
  - 동시성은 여러 개의 프로세스가 동시에 작업을 수행하는 것을 말합니다.
  - 이는 자원에 대한 동시 접근으로 인한 문제(경쟁 상태, 교착 상태 등)를 야기할 수 있습니다.
  - 이를 해결하기 위해 동기화 메커니즘(`세마포어`, `뮤텍스` 등)을 사용하여 리소스에 대한 접근을 조정합니다.

2. **세마포어 (Semaphore)**
  - 동시성 제어를 위한 방법 중 하나로, 특정 자원의 사용 가능한 단위 수를 나타내는 정수값을 가지며 이를 통해 자원에 대한 동시 접근을 제한합니다.
  - `세마포어` 는 `뮤텍스` 와 달리 소유할 수 없으며, `세마포어` 는 `뮤텍스` 를 구현할 수 있습니다.
  - **초기화**: 세마포어는 사용 가능한 자원의 수로 초기화됩니다. 예를 들어, 동시에 사용할 수 있는 자원이 3개인 경우, 세마포어는 3으로 초기화됩니다.
  - **자원 요청**
    - 프로세스나 스레드가 자원을 사용하려고 할 때, 세마포어 값을 감소시킵니다. 이를 `wait` 또는 `P (Proberen)` 연산이라고 합니다.
    - 세마포어의 현재 값이 0보다 크면, 세마포어 값을 1 감소시키고 계속 진행합니다. 이를 `P` 연산이라고 합니다.
    - 세마포어의 현재 값이 0이면, 자원이 더 이상 없음을 의미하므로 프로세스나 스레드는 대기 상태에 들어갑니다. 이를 `wait` 연산이라고 합니다.
  - **자원 반환**
    - 프로세스나 스레드가 자원 사용을 마치면, 세마포어 값을 증가시킵니다. 이를 `signal` 또는 `V (Verhogen)` 연산이라고 합니다.
    - 세마포어의 현재 값이 0보다 크면, 세마포어 값을 1 증가시키고 계속 진행합니다. 이를 `V` 연산이라고 합니다.
    - 세마포어의 현재 값이 0이면, 대기 중인 프로세스나 스레드가 있음을 의미하므로 대기 중인 프로세스나 스레드 중 하나를 깨웁니다. 이를 `signal` 연산이라고 합니다.
  - **분류 유형**
    - **이진 세마포어 (Binary Semaphore)**
      - 값이 0 또는 1인 세마포어로, 상호 배제(`Mutex`)와 유사한 동작을 합니다.
      - 주로 단일 자원의 접근을 제어하거나 임계 영역에 대한 접근을 제어하는 데 사용됩니다.
    - **카운팅 세마포어 (Counting Semaphore)**
      - 0 이상의 값을 가질 수 있는 세마포어로, 여러 개의 동일한 자원이나 다양한 작업을 처리하는 데 사용됩니다.
  - **주의점**
    - 올바르게 사용되지 않으면 `교착 상태 (Deadlock)` 와 같은 복잡한 상황을 초래할 수 있습니다.
    - 세마포어를 사용할 때에는 프로그램의 로직을 신중하게 설계하고, 가능한 교착 상태를 방지하는 메커니즘을 구현해야 합니다.

3. **뮤텍스 (Mutex, Mutual Exclusion) - 상호 배제**
  - 동시에 여러 스레드나 프로세스에 의한 공유 자원의 동시 사용을 방지하는 메커니즘
  - 특히 멀티 스레드 환경에서, 한 번에 하나의 스레드만이 특정 자원이나 중요 섹션에 접근할 수 있도록 제어하는 데 사용됩니다.
  - **상호 배제**
    - 뮤텍스 객체는 `잠금 (Lock)` 과 `해제 (Unlock)` 연산을 통해 보호되는 섹션에 대한 접근을 제어합니다.
    - 한 스레드가 `임계 영역 (Critical Section)` 에 진입하기 위해 뮤텍스를 잠그면, 다른 스레드는 그것이 해제될 떄 까지 기다려야 합니다.
  - **소유권**
    - 뮤텍스는 `소유` 개념을 가지고 있습니다. 잠금을 소유하는 스레드만이 해당 뮤텍스를 해제할 수 있습니다.
    - 이는 잠금 상태와 잠금을 소유한 스레드 사이의 일대일 관계를 의미합니다.
  - **재진입 불가능**
    - 대부분의 뮤텍스는 재진입할 수 없습니다. 즉, 같은 스레드가 이미 잠금을 소유하고 있는 상태에서 다시 잠금을 획득하려고 하면, `교착 상태 (Deadlock)` 에 빠질 수 있습니다.
    - 이를 방지하기 위해 `재진입 가능 뮤텍스(Reentrant Mutex)` 와 같은 특별한 유형의 뮤텍스가 존재합니다.
  - **상태 확인**
    - 일반적으로 뮤텍스는 `잠금` 또는 `해제` 상태를 가지고 있습니다.
    - 스레드는 뮤텍스의 상태를 확인하고, 뮤텍스가 `잠금` 상태이면 대기하고, `해제` 상태이면 뮤텍스를 `잠금` 상태로 변경하고 임계 영역에 진입합니다.
  - **주의점**
    - 교착 상태와 같은 문제를 방지하기 위해 주의해야 하며, 뮤텍스를 사용하는 코드 영역(임계 영역)은 가능한 한 짧고 단순하게 유지하는 것이 좋습니다.
    - 또한, 뮤텍스를 너무 자주 잠그고 해제하는 것은 성능 저하를 일으킬 수 있습니다.