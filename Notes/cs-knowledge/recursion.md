# 재귀 알고리즘

자신을 호출하여 문제를 해결하는 함수의 구조를 가진 알고리즘입니다.

재귀는 문제를 더 작은 단위의 동일한 문제로 분할하여, 가장 간단한 케이스(베이스 케이스)로 줄여나간 후, 
그 결과를 바탕으로 원래 문제의 답을 찾아갑니다.

재귀 알고리즘의 가장 중요한 특징은 `베이스 케이스` 가 있어야 한다는 것입니다. 
베이스 케이스는 재귀 호출을 멈추게 하는 조건으로, 이를 통해 무한 재귀로부터 벗어날 수 있습니다.

<br>

## 시나리오

1. **분할 정복 알고리즘**
  - 문제를 더 작은 문제로 분할한 후, 이러한 작은 문제를 해결하고 그 해결책을 결합하여 원래의 문제를 해결하는 방식.
  - 병합 정렬이나 퀵 정렬 등의 알고리즘이 여기에 해당함.

2. **트리나 그래프의 탐색**
  - 트리나 그래프의 모든 노드를 방문하는 알고리즘.
  - 깊이 우선 탐색(DFS)이나 너비 우선 탐색(BFS) 등의 알고리즘이 여기에 해당함.

3. **수학적 계산**
  - 팩토리얼, 피보나치 수열 등의 수학적 연산을 재귀를 통해 간결하게 표현할 수 있음.

4. **백트래킹**
  - 해결책의 공간을 탐색하면서 문제의 해결책을 찾는 방식에서, 재귀는 각 선택 사항을 간편하게 탐색할 수 있는 방법을 제공합니다.
  - `n-Queens` 문제나 `순열 생성` 등에서 사용됩니다.

<br>

## 장점

1. **구조적 간결성**
  - 재귀 알고리즘은 계층적 문제를 표현할 때 코드의 복잡성을 상당히 줄여줍니다.
  - 반복문과 여러 중첩된 조건문 대신 간단하고 명확한 코드로 문제를 표현하여 코드의 가독성을 향상시킵니다.

2. **상태 관리의 단순화**
  - 현재 문제 상태를 호출 스택에 자동으로 저장하므로 별도의 상태 관리 로직이 필요하지 않습니다.
  - 각 호출의 상태가 해당 호출의 로컬 컨텍스트에 제한되어, 어떤 변수가 어디서 영향을 받고 있는지 파악하기 쉽습니다.

3. **문제의 추상화 수준 높이기**
  - 구현 세부 사항에 덜 집중하고 문제의 고조적 측면에 더 초점을 맞출 수 있습니다.
  - 개발자가 "어떻게" 보다 "무엇을" 에 집중할 수 있게 합니다.

4. **확장성**
  - 문제의 규모 변경에 대해 유연합니다. 예를 들어, 트리의 깊이가 깊어져도 재귀 함수를 사용하는 로직은 그대로 유지될 수 있습니다.

<br>

## 단점

1. **스택 오버플로우**
  - 재귀적으로 너무 많은 함수 호출이 발생하면, 시스템 스택에 너무 많은 프레임이 쌓여 스택 오버플로우가 발생할 수 있습니다.
  - 따라서, 깊은 재귀는 시스템 리소스를 과도하게 소모할 위험이 있습니다.

2. **비효율적인 메모리 사용**
  - 각 재귀 호출마다 스택에 새로운 프레임이 추가되므로, 반복문을 사용하는 방식에 비해 메모리 사용이 비효율적일 수 있습니다.

3. **성능**
  - 간단한 반복문으로도 해결될 수 있는 문제를 재귀로 해결할 경우, 함수 호출로 인한 오버헤드가 발생하여 성능이 저하될 수 있습니다.